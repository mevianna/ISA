# Campo de utilização
O algoritmo de agrupamento K-means é uma técnica essencial na análise de dados e eficiente em diversos contextos. Ele opera agrupando dados e objetos com propriedades semelhantes em diferentes clusters. Essa técnica é extremamente utilizada na ciência de dados para segmentação de mercado, podendo estruturar a base de clientes em diferentes segmentos relacionados as suas características, além de pode agrupar documentos, realizar a segmentação e compactação de imagens.

##  Exemplos de utilização
- **Organização de Dados de Varejo:** O K-means é utilizado para organizar grandes volumes de dados de varejo, gerando insights competitivos para o negócio.
- **Análise do Comportamento do Cliente Online:** Empresas de compras online empregam o K-means para analisar as preferências, necessidades e comportamentos de compra dos clientes. Isso permite que as lojas online compreendam os interesses dos clientes e exibam anúncios relevantes, como um produto que você visualizou na Amazon aparecendo como anúncio no YouTube ou Facebook.
 - **Segmentação de Consumidores:** Após a análise de agrupamento, é possível identificar segmentos de consumidores. Isso é feito usando dados demográficos, psicográficos, comportamentais e de desempenho para agrupar consumidores. As informações resultantes podem ser usadas para adaptar mensagens de marketing, sortimentos de produtos e a experiência de compra geral, a fim de atender às necessidades dos clientes e aumentar o retorno sobre o investimento (ROI)
 ## Exemplo prático de utilização - Compressão de imagem
O algoritmo a seguir demonstra a compressão de imagens em tons de cinza usando o algoritmo K-means.
```python
import numpy as np
import matplotlib.pyplot as plt
from skimage import io
from sklearn.cluster import KMeans

# 1. Carregar a imagem
# Define o nome do arquivo da imagem que ser\u00E1 processada.
# Certifique-se de que este arquivo est\u00E1 na mesma pasta do seu script Python.
img_path = 'image_a00b3e.jpg' 

# 2. Pr\u00E9-processar a imagem para o K-Means
# Adiciona um tratamento de erro para o caso de o arquivo n\u00E3o ser encontrado.
try:
    X_orig = io.imread(img_path)
except FileNotFoundError:
    print(f"Erro: O arquivo '{img_path}' n\u00E3o foi encontrado na pasta do projeto.")
    print("Por favor, verifique se o nome do arquivo est\u00E1 correto e se ele est\u00E1 na mesma pasta do seu script.")
    # Interrompe a execu\u00E7\u00E3o se o arquivo n\u00E3o for encontrado.
    exit()

# Converte a imagem para tons de cinza se ela for colorida (3 canais: RGB).
# O algoritmo K-Means, como implementado aqui, funciona com uma \u00FAnica dimens\u00E3o (intensidade do pixel).
# Portanto, a convers\u00E3o \u00E9 necess\u00E1ria para imagens RGB.
if len(X_orig.shape) == 3 and X_orig.shape[2] == 3:
    # A imagem tem 3 canais (R, G, B), ent\u00E3o \u00E9 colorida.
    # Converte para tons de cinza usando uma f\u00F3rmula de pondera\u00E7\u00E3o comum.
    X_gray = np.dot(X_orig[...,:3], [0.2989, 0.5870, 0.1140])
    # Converte os valores para o formato de pixel uint8 (inteiro de 8 bits, de 0 a 255).
    X = X_gray.astype(np.uint8)
else:
    # A imagem j\u00E1 est\u00E1 em tons de cinza. O m\u00E9todo squeeze() remove dimens\u00F5es de tamanho 1.
    X = X_orig.squeeze()

# Armazena a altura e a largura da imagem original para a reconstru\u00E7\u00E3o.
height, width = X.shape[0], X.shape[1]

# 'Achata' a imagem para um array 1D de uma \u00FAnica coluna.
# Cada pixel se torna um 'ponto de dado' para o algoritmo K-Means.
X_flat = X.reshape(-1, 1).astype(float) # Converte para float para c\u00E1lculos precisos.

# 3. Configura\u00E7\u00E3o e Execu\u00E7\u00E3o do K-Means
# Define o n\u00FAmero de clusters (K), ou seja, o n\u00FAmero de tons de cinza na imagem final.
k = 4 # Neste exemplo, a imagem ser\u00E1 comprimida para ter apenas 4 tons de cinza.

# Cria uma inst\u00E2ncia do modelo K-Means da biblioteca scikit-learn.
# n_clusters=k: O n\u00FAmero de grupos a serem formados.
# init='k-means++': M\u00E9todo de inicializa\u00E7\u00E3o dos cent\u00F3ides para melhor converg\u00EAncia.
# n_init=10: Executa o algoritmo 10 vezes com diferentes inicializa\u00E7\u00F5es para encontrar a melhor solu\u00E7\u00E3o.
# random_state=42: Garante que o resultado seja reproduz\u00EDvel em diferentes execu\u00E7\u00F5es.
kmeans_model = KMeans(n_clusters=k, init='k-means++', n_init=10, random_state=42)

# Treina o modelo nos dados 'achatados' e atribui um r\u00F3tulo de cluster a cada pixel.
labels = kmeans_model.fit_predict(X_flat)

# Obt\u00E9m os cent\u00F3ides, que s\u00E3o os valores m\u00E9dios de intensidade de cada cluster.
# Estes s\u00E3o os 4 tons de cinza que representar\u00E3o a imagem.
centroids = kmeans_model.cluster_centers_

# 4. Reconstruir a Imagem Comprimida
# Para cada pixel, substitui seu valor original pelo valor do cent\u00F3ide ao qual ele foi agrupado.
X_compressed = centroids[labels]
# Remodela o array de volta ao formato da imagem original (altura x largura).
X_compressed = X_compressed.reshape(height, width).astype("uint8")

# 5. Exibir e Salvar a Imagem
# Exibe a imagem comprimida em uma janela gr\u00E1fica.
io.imshow(X_compressed)
plt.title(f'Imagem Comprimida (k={k} tons de cinza)')
plt.show() # Mostra a janela da imagem na tela.

# Opcional: Salva a imagem comprimida em um arquivo no disco.
output_filename = f'imagem_comprimida_{k}.png'
plt.savefig(output_filename) # Salva a imagem na mesma pasta do script.
print(f"Imagem comprimida salva como: {output_filename}")
```
 


![Captura de tela 2025-06-30 224450](https://github.com/user-attachments/assets/1b9e24a6-51ff-496a-9053-064c61866dc5)
